import { getDataFromTree } from '@apollo/react-ssr';
import { ChunkExtractor, ChunkExtractorManager } from '@loadable/server';
import { InMemoryCache } from 'apollo-cache-inmemory';
import { ApolloClient } from 'apollo-client';
import { HttpLink } from 'apollo-link-http';
import { ApolloServer, gql } from 'apollo-server-express';
import express from 'express';
import { filter, find } from 'lodash';
import fetch from 'node-fetch';
import path from 'path';
import React from 'react';
import { ApolloProvider } from 'react-apollo';
import { renderToString } from 'react-dom/server';
import { Helmet } from 'react-helmet';
import { StaticRouter } from 'react-router-dom';
import serialize from 'serialize-javascript';
import { ServerStyleSheet } from 'styled-components';

import App from './app/App';

const { APP_ENV, NODE_ENV } = process.env;

// This is the stats file generated by webpack loadable plugin
const statsFile = path.resolve('./build/loadable-stats.json');

let assets: any;

const syncLoadAssets = () => {
  assets = require(process.env.RAZZLE_ASSETS_MANIFEST!);
};
syncLoadAssets();

const typeDefs = `
  type Author {
    id: Int!
    firstName: String
    lastName: String
    """
    the list of Posts by this author
    """
    posts: [Post]
  }

  type Post {
    id: Int!
    title: String
    author: Author
    votes: Int
  }

  # the schema allows the following query:
  type Query {
    posts: [Post]
    author(id: Int!): Author
  }

  # this schema allows the following mutation:
  type Mutation {
    upvotePost (
      postId: Int!
    ): Post
  }
`;

// example data
const authors = [
  { id: 1, firstName: 'Tom', lastName: 'Coleman' },
  { id: 2, firstName: 'Sashko', lastName: 'Stubailo' },
  { id: 3, firstName: 'Mikhail', lastName: 'Novikov' },
];

const posts = [
  { id: 1, authorId: 1, title: 'Introduction to GraphQL', votes: 2 },
  { id: 2, authorId: 2, title: 'Welcome to Meteor', votes: 3 },
  { id: 3, authorId: 2, title: 'Advanced GraphQL', votes: 1 },
  { id: 4, authorId: 3, title: 'Launchpad is Cool', votes: 7 },
];

const resolvers = {
  Query: {
    author: (_: any, { id }: { id: any }) => find(authors, { id }),
    posts: () => posts,
  },

  Mutation: {
    upvotePost: (_: any, { postId }: { postId: any }) => {
      const post = find(posts, { id: postId });
      if (!post) {
        throw new Error(`Couldn't find post with id ${postId}`);
      }
      post.votes += 1;
      return post;
    },
  },

  Author: {
    posts: (author: any) => filter(posts, { authorId: author.id }),
  },

  Post: {
    author: (post: any) => find(authors, { id: post.authorId }),
  },
};

const link = new HttpLink({
  // tslint:disable:next-line
  fetch,
  uri: 'http://localhost:3000/graphql',
});

const apolloServer = new ApolloServer({ typeDefs, resolvers });

const server = express();
apolloServer.applyMiddleware({ app: server, path: '/graphql' });
server
  .disable('x-powered-by')
  .use(express.static(process.env.RAZZLE_PUBLIC_DIR!))
  .get('/*', async (req: express.Request, res: express.Response) => {
    const client = new ApolloClient({
      cache: new InMemoryCache(),
      link,
      ssrMode: true,
    });
    const context = {};
    const sheet = new ServerStyleSheet();
    const extractor = new ChunkExtractor({
      entrypoints: ['client'],
      statsFile,
    });
    await getDataFromTree(
      <ApolloProvider client={client}>
        <StaticRouter context={context} location={req.url}>
          <App />
        </StaticRouter>
      </ApolloProvider>
    );
    const initialApolloState = client.extract();
    try {
      const markup = renderToString(
        sheet.collectStyles(
          <ChunkExtractorManager extractor={extractor}>
            <ApolloProvider client={client}>
              <StaticRouter context={context} location={req.url}>
                <App />
              </StaticRouter>
            </ApolloProvider>
          </ChunkExtractorManager>
        )
      );
      const chunkedScriptTags = extractor.getScriptTags();
      const chunkedLinkTags = extractor.getLinkTags();
      const chunkedStyleTags = extractor.getStyleTags();
      const helmet = Helmet.renderStatic();
      const styleTags = sheet.getStyleTags();
      res.send(`
        <!doctype html>
        <html lang="">
          <head ${helmet.htmlAttributes.toString()}>
            ${helmet.title.toString()}
            ${helmet.meta.toString()}
            ${helmet.link.toString()}
            ${styleTags}
            <script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>
            ${
              assets.client.css
                ? `<link rel="stylesheet" href="${assets.client.css}">`
                : ''
            }
            ${chunkedLinkTags}
            ${chunkedStyleTags}
            ${
              process.env.NODE_ENV === 'production'
                ? `<script src="${assets.client.js}" defer></script>`
                : `<script src="${assets.client.js}" defer crossorigin></script>`
            }
          </head>
          <body ${helmet.bodyAttributes.toString()}>
            <div id="root">${markup}</div>
          </body>
          <script>
            window.env = ${serialize({ APP_ENV, NODE_ENV })}
          </script>
          <script>
            window.__APOLLO_STATE__ = ${JSON.stringify(
              initialApolloState
            ).replace(/</g, '\\u003c')};
          </script>
          ${chunkedScriptTags}
        </html>
      `);
    } catch (e) {
      console.log('Failed to render!');
      console.error(e);
      res.status(500);
      res.setHeader('Cache-Control', 'no-store');
      res.send('Something went wrong!');
    } finally {
      sheet.seal();
    }
  });

export default server;
